title: 常用设计模式
date: 2016-05-14 11:37:28
tags:
---

# 设计原则
1. 依赖倒转
依赖抽象，不依赖具体。  
在工厂方法中，就体现了这一点， creator 中的公共主体逻辑可以先写好，写个抽象方法来延迟实现，  
让子类是具体实现。在 Volley 中的 http client 就体现了这一点。它会根据 SDK level 来  
采取不同的实现。
# 常见设计模式
1. 工厂模式
分为，简单工厂、抽象工厂和工厂方法，一共3种。
2. 外观模式
3. 适配者模式
4. 工厂方法模式
5. 抽象工厂方法
6. 原型模式
7. 中介模式
8. 代理模式
9. 观察者模式
10. 命令模式

## 设计模式的具体实现和理解
### 简单工厂
**使用情景**：  
不想让调用者，知道具体实现，直接返回一个接口，让操作者去调用。对外仅仅暴漏接口和  
简单工厂，具体的实现隐藏起来。  
**结构说明**：  
接口和具体实现类，以及工厂，处于一层，调用者处于另外一层。  
如果需要调用不同的实现，可以选择  
1. 带入参
2. 或者自己读取配置文件。
 带入参，就意味着，调用者需要知道内部具体实现的  
部分细节了，这加大了，调用者的学习成本，值得注意的一点。  
**优缺点**：  
改模式的优点是：调用者不关心具体的实现。把调用者和具体实现类解耦。
缺点：如果需要带入参，那么调用者就需要知道部分具体实现细节。


### 外观模式
**使用情景**：调用者需要分别调用不同子模块的方法，来实现一个需求。外观模式，就是用了一个  
对各子模块的包装( Facade )了，调用者只需要调用 Facade 就可以实现分别调用各子模块了。  
**结构说明**：  
  Facade 包装一下各子模块的功能，对外提供一个包装后的功能方法，对外提供。  
**优缺点**：  
优点是：调用者不关心那么多子模块的实现了，直接调用包装后的 Facade 。  
缺点： 如果一些简单的功能，不知道是直接调用具体的模块好，还是用 Facade 好。  
**和相关模式的区别**：  
1. 简单工厂模式
**相同点是** 都是不让调用者知道具体的实现细节，节省调用者的理解成本。  
**不同点是** 简单工厂返回的是接口，外观，是通过一个包装类来提供的。  


### 适配器模式
简单来举例说，比如，第一版本一个类 A，有方法 A1 和 A2 ，现在第二版本，类 A 的升级类 B ，  
有方法 B1 , B2 , B3 , B4 。但是呢，现在是处于第一版本向第二版本的过渡期，既要保持第二版本  
的实现（虽然不大稳定），也要拥有之前版本的实现。一般来说，如果从业务角度，如果 A1  方法和 B1  
方法，较接近，而且参数之类也可以兼容的话，就可以在类 B 的方法 B1 中，调用类 A  的方法 A1 。  
至于类 A  什么时候传入到类 B 中，可以随意选择了，但是必须得在调用方法 B1 之前。


## 工厂方法模式
和简单工厂比较像。他把公共逻辑写完，剩下的未知的（或者个性化）实现，写一个抽象方法，  
留给子类去定制化实现。

## 抽象工厂方法
和工厂方法类似，并且会常常一起使用，主要特点，就是为一个特定的产品，实现定制化一个 Factory 。

## 原型模式
java 中的 clone 是浅度克隆，基本类型没问题，但是引用类型的话，clone 是直接把对象的值，  
拷贝过去的。因此需要自己重新复制。


## 中介模式
和外观模式有点像，对象之间通信比较复杂，并且频繁的话，可以抽离出来，让 Mediator 来做  
这些复杂的操作，中介模式的结构并不固定。

## 代理模式
在调用者和被访问的对象之间，引入一定程度上的中间者，试图不让调用者和被访问的对象直接联系。  
这么做的原因可能各种各样。例如，目标对象，可能有很多公开方法，但是这些公开方法，大部分只是  
希望给自己内部使用，仅有小部分是对开公开的。因此可以封装一层。

## 观察者模式
一对多的关系，被观察者的改变，会引起众多观察者的关注。需要注意观察者的生命周期，需要及时注销。


## 命令模式
就是调用者，不关心具体的实现，
